# Lock-free hash table via split-ordered list

Наша задача реализовать хеш-таблицу так, чтобы многопоточный доступ к ней был без задержек. И чтобы увеличение кол. ячеек тоже было быстро.

У нас есть теорминимум [тут](https://habr.com/ru/post/250383/) и [тут](https://habr.com/ru/post/250523/).

## Сборка под MinGW64

1. Перейти в папку с этим ридми, открыть там консоль.
2. Выполнить команды:
```
mkdir build
cd build
cmake .. -G "MinGW Makefiles"
mingw32-make.exe
```
3. Теперь у нас в папке build есть исполняемый файл с тестами.

## Тестирование

Я написал небольшой алгоритм для рандомизированного тестирования структуры данных.
Выполняется 100000 случайных операций по добавлению, удалению, проверке на наличие элемента.
Сравнение производим с обычным битовым полем.

## Описание SplitOrdered list

Как реализовать однопоточный список очевидно.
Но если с ним теперь будут работать несколько потоков, то он сломается.
Вся проблема с удалением.

![image](https://user-images.githubusercontent.com/25401699/205921855-6cbd4751-5b23-4c74-81a9-978394f68bd1.png)

Решение этой проблемы - двухфазное удаление.
Первая фаза — логическое удаление — помечает элемент как удаленный, не исключая его из списка.
Вторая фаза — физическое исключение — исключает элемент из списка (а третья фаза — физическое удаление — выполняется схемой безопасного удаления памяти).
Смысл логического удаления — пометить удаляемый элемент таким образом, чтобы CAS на нем не сработал. Для этого Harris предложил использовать младший
бит указателя next элемента.

![image](https://user-images.githubusercontent.com/25401699/205941650-88abe8ff-a898-4448-a221-2905ab35eb8c.png)

## Описание HashTable

Вот у нас есть обычный советский hash-map.
Его проблема в том, что при изменении размера таблицы - нужно перестраивать все с нуля.

![image](https://user-images.githubusercontent.com/25401699/205914735-97cea0cd-0ca1-438e-bf52-9737b659d897.png)

Это для однопоточной реализации сложно, ну а сделать это быстро для многопоточной сложно тем более.

Решение этой проблемы - split-ordered list - когда мы разбиваем уже существующий bucket на две части.

Давайте хранить таблицу в виде списка. У нас будет два типа элементов - sentinel, regular. Первые - для обозначения bucket - все, что идет после него и до следующего
sentinel - лежит в данном bucket. Вторые - сами элементы.

![image](https://user-images.githubusercontent.com/25401699/205920213-d92a0a25-b2c7-4237-8bc2-92c39215b75c.png)

Критерий сортировки такой - мы берем двоичное представление - переварачиваем, справа приписываем: sentinel - 0, regular - 1.
Получаем новые числа, по которым сортируем.

Теперь вставка и удаление очевидны.

### Вставка

![image](https://user-images.githubusercontent.com/25401699/205920772-13f7b91f-2135-4cde-8d3d-0c6b35c0e61d.png)

![image](https://user-images.githubusercontent.com/25401699/205920788-7a09b171-44c5-4928-9239-a31ebf5dbeb6.png)

### Отрисовка содержимого

Я добавил graphviz.
Пример из статьи можно увидеть и в моей структуре данных.

![image](https://user-images.githubusercontent.com/25401699/207375407-7298822a-6652-45ec-a3dd-f8de12e84dc5.png)

![image](https://user-images.githubusercontent.com/25401699/207375462-902621bc-b582-4fd6-b8a8-54b3017fa4dd.png)


