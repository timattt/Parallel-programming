# Спинлоки

Мы хотим сделать критическую секцию.
Делаем с помощью циклов, чтобы пока один поток находится в критической секции - другие катались в цикле.

## Полезные функции

* compare_exchange_weak - true, если в this находится значение nExpected (в этом случае оно меняется на nNew), false в случае неудачи (тогда nExpected будет содержать текущее значение переменной по адресу pAddr).
* store - кладем в атомарную переменную что-нибудь - одна операция записи.
* load - читаем значение атомарной переменной, соответственно одна операция чтения.
* fetch_add - сначала возвращает старое значение, а уже потом прибавляет.

## TAS

Test and store

Самый простой вариант блокировки. У нас есть атомарная переменная. Поток смотрит - она единица или нет.
Если ноль, то поток идет дальше и ставит ее в 1. Если 1, то ждет в цикле.
При разблокировке поток ставит ее значение в 0.

## TTAS

test and test and set

Все аналогично предыдущему случаю, но мы знаем, что операция compare_exchange требует синхронизации для записи, что тратит лишнее время.
А вот операция load - требует только чтения. Поэтому мы будет ждать в цикле, который только читает.

## Spin lock

Нам выдают номерки. Как в гос учреждении. Есть две атомарные переменные - текущий номерок и последний выданный номерок.
Поток блокирует - ему выдают номерок равный последнему выданному. Он ждет, пока текущий не равен его номерку. И потом идет дальше.
При разблокировке мы текущий номер увеличиваем на 1.

![image](https://user-images.githubusercontent.com/25401699/202441339-47960e2c-ca94-4f85-9a5d-9c07c8fd0ce7.png)

## Полезности

* [статья про кэши в многопроцессорных системах](https://habr.com/ru/post/183834/)

## Заметки

* Каждый поток имеет свой приватный кэш, в котором хранятся копии необходимых линий, а некоторые из них при этом локально модифицированы.
* Протокол когерентности обеспечивает единое пространство памяти для потоков - чтобы в их локальных кешах были одинаковые значения.
* Протокол MESI (modified, exclusive, shared, invalid) - пример протокола когерентности. Далее диаграмма изменения состояния кэш-линий. 

![image](https://user-images.githubusercontent.com/25401699/203031375-47b51cbb-228f-4286-817a-f6ec3d4d6249.png)

* Классические ReadModifyWrite операции: CompareAndSwap, FetchAndAdd, TestAndSet
* Использование CAS влечет проблему ABA. Один поток считал значение из разделяемой памяти A. Потом другой записал сначала туда же B и потом сразу A.
* Но первый сравнит данные и ничего не заметит.
* От спинлока мьютекс отличается передачей управления планировщику для переключения потоков при невозможности захвата мьютекса.
