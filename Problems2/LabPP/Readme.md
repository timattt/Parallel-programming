# Лаба по парпроге

## Сборка

1. Соберите cmake
2. Теперь в папке сборки будут разные скрипты на питоне
3. Можно запустить скрипт с рандомизированным юнит-тестом, который сравнит - одинаковы ли парал. версия и обычная версия

## Допуск

1. Вектор расстояний зависимости:

$$
\vec D = \begin{pmatrix}
-8 \\
3
\end{pmatrix}
$$

2. Вектор направлений:

$$
\vec d = \begin{pmatrix}
\textbf{>} \\
\textbf{<}
\end{pmatrix}
$$

3. По индексу i будет антизависимость, а по индексу j будет потоковая зависимость.

## Вопросы

### 1. Ускорение и эффективность параллельных алгоритмов.

* Ускорением параллельного алгоритма называют отношение времени выполнения
лучшего последовательного алгоритмам к времени выполнения параллельного алгоритма.

* Эффективность

$$
E = \frac{S}{p}
$$

Где S - ускорение, а p - кол процессов.

### 2. Закон Амдаля

$$
S = \frac{T_1}{T_p} = \frac{T_1}{\alpha T_1 + \frac{(1- \alpha) T_1}{p}} \le \frac{1}{\alpha}
$$

Где альфа - доля последовательных операций.

### 3. Свойства канала передачи данных. Латентность.

* Латентность — временна́я задержка сигнала при работе динамической оперативной памяти со страничной организацией.

### 4. Виды обменов «точка-точка»: синхронные, асинхронные. Буферизация данных.

* Вид обмена «точка-точка» - обмен данными между двумя процессами. Синхронный обмен - блокирующий обмен. Ассинхронный - неблокирующий.
* Буферизация данных - использования промежуточного буфера во время передачи.

### 5. Синхронизация выполнения.

* Требуем от процессов, чтобы в некоем месте, прежде чем идти дальше, они дождались всех остальных.

### 6. Условия Бернстайна

$$
W(P) \cap W(Q) = W(P) \cap R(Q) = R(P) \cap W(Q) = \emptyset
$$

### 7. Расстояние зависимости. Его влияние на возможность распараллеливания простого
цикла.

* Расстояние зависимости - разность итерации стока и итерации источника.
* Если расстояние зависимости D<0, то между операторами тела цикла существует
антизависимость. Цикл может быть распараллелен так, что каждая итерация будет
выполняться отдельным исполнителем, если перед началом выполнения итераций
продублировать необходимые входные данные на исполнителях.
* Если расстояние зависимости D > 0, то между операторами тела цикла существует
потоковая зависимость. При D > 1 цикл может быть распараллелен не более чем на D
исполнителях.
* Если расстояние зависимости D = 0, то тип зависимости между операторами тела
цикла в общем случае не определен. Цикл может быть распараллелен так, что каждая
итерация будет выполняться отдельным исполнителем.

### 8. Расстояние зависимости для вложенных циклов.

* Вектор расстояний зависимости для цикла - из вектора итераций, соответствующего
итерации стока зависимости, вычитаем вектор итерации, соответствующий итерации
источника зависимости.

### 9. Вектор направлений. Его влияние на возможность распараллеливания вложенных
циклов.

* Компоненты вектора направлений d (а это —
символьный вектор) определяются следующим образом: 

$$
d_i = "=", если D_i = 0
$$
$$
d_i = ">", если D_i < 0
$$
$$
d_i = "<", если D_i > 0
$$

* Распараллеливание всегда возможно по =.

### 10. Условия возможности перестановки вложенных циклов с сохраненнием результата
вычислений

* Приемы разделения цикла, выравнивания цикла и эквивалентная перестановка
операторов в теле цикла достаточны для
«обхода» зависимостей, связанных с циклом, если:
- в цикле нет рекурсивных истинных зависимостей.
- расстояние для каждой зависимости есть константа, не зависящая от индекса цикла.

### 11. Проанилизировать возможность распараллеливания следующих циклов:

* 1. зависмость только в индексе 0 - можно аккуратно параллелить цикл
* 2. зависимости нет - можно параллелить цикл
* 3. зависимость есть - распараллелить нельзя
* 4. зависимости нет - можно параллелить цикл
* 5. зависимость есть - распараллелить нельзя

## Выполнение

## Решение с MPI

Построим для 10 процессов. Апроксимируем кривой ```~ 1/x ```. Видно, что точки в пределах погрешности соответствуют данной кривой.
Поэтому для большего кол. процессов тестировать нет смысла.
   
Построим три графика.

1. Время выполнения от кол. процессов
2. Ускорение от кол. процессов
3. Эффективность от кол. процессов 

![image](https://user-images.githubusercontent.com/25401699/206836076-9c381d0d-9990-4435-9ce3-f8607dc7d6eb.png)
